///////////////////////////////////////////////////////////////////////////////
//  Copyright Christopher Kormanyos 2018.
//  Distributed under the Boost Software License,
//  Version 1.0. (See accompanying file LICENSE_1_0.txt
//  or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef RANDOM_2018_06_10_
  #define RANDOM_2018_06_10_

  #include <algorithm>
  #include <cstddef>
  #include <cstdint>
  #include <initializer_list>
  #include <vector>

  // Implement portions of <random> for compilers that do not have it.

  namespace std {

  class seed_seq
  {
  public:
    using result_type = uint_least32_t;

    seed_seq() : internal_sequence() { }

    template<typename T>
    seed_seq(const std::initializer_list<T>& init_list)
      : internal_sequence(init_list.begin(), init_list.end()) { }

    template<typename input_iterator_type>
    seed_seq(input_iterator_type first, input_iterator_type last)
      : internal_sequence(first, last) { }

    template<typename random_iterator_type>
    void generate(random_iterator_type first, random_iterator_type last) const
    {
      typedef typename std::iterator_traits<random_iterator_type>::value_type value_type;

      std::fill(first, last, static_cast<value_type>(0x8B8B8B8BU));

      std::size_t s = internal_sequence.size();

      std::size_t n = last - first;

      std::size_t t = (n >= 623) ? 11 :
                      (n >=  68) ?  7 :
                      (n >=  39) ?  5 :
                      (n >=   7) ?  3 :
                      (n - 1)/2;

      std::size_t p = (n - t) / 2;
      std::size_t q = p + t;
      std::size_t m = (std::max)(s + 1, n);

      value_type mask = 0xFFFFFFFFU;
      for(std::size_t k = 0; k < m; ++k)
      {
        value_type r1(*(first + (k % n)) ^ *(first + ((k + p) % n)) ^ *(first + (((k + n) - 1) % n)));

        r1 = r1 ^ (r1 >> 27);
        r1 = (r1 * 1664525U) & mask;

        value_type r2(r1 + ((k == 0) ? s :
                            (k <= s) ? k % n + internal_sequence[k - 1] :
                            (k % n)));

        *(first + ((k + p) % n)) = (*(first + ((k + p) % n)) + r1) & mask;
        *(first + ((k + q) % n)) = (*(first + ((k + q) % n)) + r2) & mask;
        *(first + (k % n)) = r2;
      }

      for(std::size_t k = m; k < m + n; ++k)
      {
        value_type r3((*(first + (k % n)) + *(first + ((k + p) % n)) + *(first + (k+n-1)%n)) & mask);

        r3 = r3 ^ (r3 >> 27);
        r3 = (r3 * 1566083941U) & mask;

        value_type r4 = static_cast<value_type>(r3 - (k % n));

        *(first + ((k + p) % n)) ^= r3;
        *(first + ((k + q) % n)) ^= r4;
        *(first +  (k % n)) = r4;
      }
    }

    template<typename output_iterator_type>
    void param(output_iterator_type destination) const
    {
      static_cast<void>(destination);
    }

    size_t size() const { return internal_sequence.size(); }

    seed_seq(const seed_seq&) = delete;
    void operator=(const seed_seq&) = delete;

  private:
    std::vector<result_type> internal_sequence;
  };

  template <class UnsignedIntegralType,
            UnsignedIntegralType AxValue,
            UnsignedIntegralType CxValue,
            UnsignedIntegralType MxValue>
  UnsignedIntegralType linear_congruential_value(UnsignedIntegralType previous) noexcept
  {
    const std::uint64_t multiplier = std::uint64_t(std::uint64_t(previous) * AxValue) + CxValue;

    return UnsignedIntegralType(multiplier % MxValue);
  }

  template <class UnsignedIntegralType, UnsignedIntegralType CxValue, UnsignedIntegralType MxValue>
  UnsignedIntegralType linear_congruential_seed(UnsignedIntegralType s) noexcept
  {
    return s;
  }

  template <typename UnsignedIntegralType,
            const UnsignedIntegralType AxValue,
            const UnsignedIntegralType CxValue,
            const UnsignedIntegralType MxValue>
  class linear_congruential_engine
  {
  public:
    static_assert((MxValue == 0) || ((AxValue < MxValue) && (CxValue < MxValue)),
                  "Error: Bad parameters for linear_congruential_engine");

    using result_type                       = UnsignedIntegralType;
    static constexpr result_type multiplier = AxValue;
    static constexpr result_type increment  = CxValue;
    static constexpr result_type modulus    = MxValue;

    static constexpr result_type(min)() noexcept
    {
      return (CxValue == 0) ? result_type(1U) : result_type(0U);
    }

    static constexpr result_type(max)() noexcept
    {
      return static_cast<result_type>(MxValue - 1U);
    }

    static constexpr result_type default_seed = 1U;

    linear_congruential_engine() noexcept
      : my_previous(linear_congruential_seed<result_type, CxValue, MxValue>(default_seed)) { }

    explicit linear_congruential_engine(result_type s) noexcept
      : my_previous(linear_congruential_seed<result_type, CxValue, MxValue>(s)) { }

    void seed(result_type s = default_seed) noexcept
    {
      my_previous = linear_congruential_seed<result_type, CxValue, MxValue>(s);
    }

    result_type operator()() noexcept
    {
      my_previous = linear_congruential_value<result_type, AxValue, CxValue, MxValue>(my_previous);

      return my_previous;
    }

    void discard(unsigned long long skip) noexcept
    {
      result_type tmp = my_previous;

      for( ; 0U < skip; --skip)
      {
        tmp = linear_congruential_value<UnsignedIntegralType, AxValue, CxValue, MxValue>(tmp);
      }

      my_previous = tmp;
    }

  private:
      result_type my_previous;
  };

  using min_stdrand = linear_congruential_engine<std::uint_fast32_t,
                                                 UINT32_C(48271),
                                                 UINT32_C(0),
                                                 UINT32_C(2147483647)>;
  }

#endif // RANDOM_2018_06_10_
