
/*  Copyright (C) 2014 Christopher Kormanyos

  This file closely adheres to the implementation of <array>
  that is specified in ISO/IEC 14882:2011, Chapter 23.3.2.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef __STD_HEADER_ARRAY
  #define __STD_HEADER_ARRAY 1

  #include <algorithm>
  #include <cstddef>
  #include <func_exception>
  #include <iterator>

  // Implement most of std::array for compilers that do not yet support it.
  // See ISO/IEC 14882:2011 Chapter 23.3.2.

  namespace std
  {
    template<typename T, std::size_t N>
    struct array
    {
    public:
      // Standard container-local type definitions.
      typedef T&                                     reference;
      typedef const T&                               const_reference;
      typedef T*                                     iterator;
      typedef const T*                               const_iterator;
      typedef std::size_t                            size_type;
      typedef std::ptrdiff_t                         difference_type;
      typedef T                                      value_type;
      typedef T*                                     pointer;
      typedef const T*                               const_pointer;
      typedef std::reverse_iterator<iterator>        reverse_iterator;
      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;

      value_type elems[N];

      // There is no explicit construct/copy/destroy for an aggregate type.

      // Functions for accessing the beginning and ending iterators.
      iterator               begin  () noexcept       { return  elems; }
      iterator               end    () noexcept       { return (elems + N); }
      const_iterator         begin  () const noexcept { return  elems; }
      const_iterator         end    () const noexcept { return (elems + N); }
      const_iterator         cbegin () const noexcept { return  elems; }
      const_iterator         cend   () const noexcept { return (elems + N); }
      reverse_iterator       rbegin () noexcept       { return reverse_iterator      (elems + N); }
      reverse_iterator       rend   () noexcept       { return reverse_iterator      (elems); }
      const_reverse_iterator rbegin () const noexcept { return const_reverse_iterator(elems + N); }
      const_reverse_iterator rend   () const noexcept { return const_reverse_iterator(elems); }
      const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(elems + N); }
      const_reverse_iterator crend  () const noexcept { return const_reverse_iterator(elems); }

      // Functions for random access to elements.
      reference       operator[](const size_type i)       { return elems[i]; }  // No range check.
      const_reference operator[](const size_type i) const { return elems[i]; }  // No range check.
      reference       at        (const size_type i)       { rangecheck(i); return elems[i]; }
      const_reference at        (const size_type i) const { rangecheck(i); return elems[i]; }

      // Functions for access to the front and back elements.
      reference       front()       { return elems[size_type(0U)]; }
      const_reference front() const { return elems[size_type(0U)]; }
      reference       back ()       { return elems[size_type(N - 1U)]; }
      const_reference back () const { return elems[size_type(N - 1U)]; }

      // Size functions.
      constexpr size_type size    () noexcept { return N; }
      constexpr size_type max_size() noexcept { return N; }
      constexpr bool      empty   () noexcept { return (size() == size_type(0U)); }

      // Raw data pointer access functions.
      const_pointer data() const noexcept { return &elems[size_type(0U)]; }
      pointer data()             noexcept { return &elems[size_type(0U)]; }

      // Algorithmic functions.
      // Note: The swap member function is missing type simplification via std::declval.
      template<typename T2>
      void swap(array<T2, N>& other)
      {
        std::swap_ranges(begin(), end(), other.begin());
      }

      void fill(const value_type& value)
      {
        std::fill_n(elems, N, value);
      }

    private:
      static void rangecheck(const size_type i)
      {
        if(i >= N) { std::__throw_out_of_range(); }
      }
    };

    // Global array comparison functions.
    template<typename T, std::size_t N>
    inline bool operator==(const array<T, N>& left, const array<T, N>& right) { return std::equal(left.begin(), left.end(), right.begin()); }

    template<typename T, std::size_t N>
    inline bool operator!=(const array<T, N>& left, const array<T, N>& right) { return !(left == right); }

    template<typename T, std::size_t N>
    inline bool operator< (const array<T, N>& left, const array<T, N>& right) { return std::lexicographical_compare(left.begin(), left.end(), right.begin(), right.end()); }

    template<typename T, std::size_t N>
    inline bool operator> (const array<T, N>& left, const array<T, N>& right) { return (right < left); }

    template<typename T, std::size_t N>
    inline bool operator<=(const array<T, N>& left, const array<T, N>& right) { return !(left > right); }

    template<typename T, std::size_t N>
    inline bool operator>=(const array<T, N>& left, const array<T, N>& right) { return !(left < right); }

    // Specialization of the global std::swap function for arrays.
    // Note: The global swap function is missing type simplification via std::declval.
    template<typename T, std::size_t N>
    inline void swap(array<T, N>& left, array<T, N>& right) { left.swap(right); }

    // TBD: Support for the tuple-array interface is not yet implemented.
  }

#endif // __STD_HEADER_ARRAY = 1
